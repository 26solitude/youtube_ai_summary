package org.example.youtubeaisummary;

import io.github.thoroldvix.api.*;
import org.example.youtubeaisummary.dto.JobStatusDto;
import org.example.youtubeaisummary.exception.NoSubtitlesFoundException;
import org.example.youtubeaisummary.repository.InMemoryJobRepository;
import org.example.youtubeaisummary.service.SseNotificationService;
import org.example.youtubeaisummary.service.YoutubeApiSubtitleService;
import org.example.youtubeaisummary.vo.YoutubeVideo;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class SubtitleServiceTest {

    private final String testJobId = "test-job-123";
    private final String testVideoId = "testVideoId";

    // 테스트 대상의 의존성들을 Mock으로 생성
    @Mock
    private YoutubeTranscriptApi mockApi;
    @Mock
    private InMemoryJobRepository mockJobRepository;
    @Mock
    private SseNotificationService mockSseNotificationService;

    // @InjectMocks는 @Mock으로 생성된 객체들을 테스트 대상 객체에 자동으로 주입
    @InjectMocks
    private YoutubeApiSubtitleService subtitleService;

    private YoutubeVideo testVideo;

    @BeforeEach
    void setUp() {
        // 모든 테스트 전에 공통으로 필요한 Mock 객체 설정
        testVideo = mock(YoutubeVideo.class);
        when(testVideo.getVideoId()).thenReturn(testVideoId);

        subtitleService.setDependencies(mockJobRepository, mockSseNotificationService);
    }

    @Test
    @DisplayName("성공: 자막 추출 및 모든 과정 정상 완료")
    void fetchSubs_successPath() throws Exception {
        // Arrange (준비)
        // API 호출 시 반환될 Mock 객체들 설정
        TranscriptList mockTranscriptList = mock(TranscriptList.class);
        Transcript mockTranscript = mock(Transcript.class);
        TranscriptContent mockTranscriptContent = mock(TranscriptContent.class);

        when(mockApi.listTranscripts(testVideoId)).thenReturn(mockTranscriptList);
        when(mockTranscriptList.spliterator()).thenReturn(Stream.of(mockTranscript).spliterator());
        when(mockTranscript.isGenerated()).thenReturn(true);
        when(mockTranscript.fetch()).thenReturn(mockTranscriptContent);

        // Act (실행)
        CompletableFuture<String> future = subtitleService.fetchSubs(testJobId, testVideo);
        future.get(); // 비동기 작업이 완료될 때까지 대기

        // Assert (검증)
        // Mockito의 InOrder를 사용하여 메서드 호출 순서를 검증
        InOrder inOrder = inOrder(mockJobRepository, mockSseNotificationService);

        // 1. '자막 추출 중' 상태 업데이트 검증
        inOrder.verify(mockJobRepository).updateJob(testJobId, JobStatusDto.JobStatus.SUBTITLE_EXTRACTING, "자막 추출을 시작합니다...");
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(
                dto -> dto.status() == JobStatusDto.JobStatus.SUBTITLE_EXTRACTING
        ));

        // 2. '자막 추출 완료' 상태 업데이트 검증
        inOrder.verify(mockJobRepository).updateJob(eq(testJobId), eq(JobStatusDto.JobStatus.SUBTITLE_EXTRACTION_COMPLETED), anyString());
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(
                dto -> dto.status() == JobStatusDto.JobStatus.SUBTITLE_EXTRACTION_COMPLETED
        ));

        // 3. SubtitleService는 더 이상 최종 완료나 에러 관련 메서드를 호출하지 않음을 검증
        verify(mockSseNotificationService, never()).errorStream(any(), any());
    }

    @Test
    @DisplayName("예외: 자동 생성 자막이 없는 경우")
    void fetchSubs_noAutoGeneratedTranscript() throws TranscriptRetrievalException {
        // Arrange
        String userErrorMessage = "이 영상에는 자동 생성된 자막이 없습니다.";
        TranscriptList mockTranscriptList = mock(TranscriptList.class);
        when(mockApi.listTranscripts(testVideoId)).thenReturn(mockTranscriptList);
        when(mockTranscriptList.spliterator()).thenReturn(Stream.<Transcript>empty().spliterator());

        // Act & Assert: 비동기 작업에서 특정 예외가 발생하는지 검증
        ExecutionException exception = assertThrows(ExecutionException.class, () -> subtitleService.fetchSubs(testJobId, testVideo).get());

        // 발생한 예외의 원인(cause)이 우리가 기대한 예외 타입과 메시지를 가졌는지 검증
        assertTrue(exception.getCause() instanceof NoSubtitlesFoundException);
        assertEquals(userErrorMessage, exception.getCause().getMessage());

        // Verify: Mock 객체들의 호출 순서 및 내용을 검증
        InOrder inOrder = inOrder(mockJobRepository, mockSseNotificationService);

        // 1. '자막 추출 중' 상태 업데이트가 먼저 호출됨
        inOrder.verify(mockJobRepository).updateJob(eq(testJobId), eq(JobStatusDto.JobStatus.SUBTITLE_EXTRACTING), anyString());
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(dto -> dto.status() == JobStatusDto.JobStatus.SUBTITLE_EXTRACTING));

        // 2. 그 다음 '실패' 상태 업데이트 및 스트림 에러 종료가 호출됨
        inOrder.verify(mockJobRepository).updateJob(eq(testJobId), eq(JobStatusDto.JobStatus.FAILED), eq(userErrorMessage));
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(dto -> dto.status() == JobStatusDto.JobStatus.FAILED));
        inOrder.verify(mockSseNotificationService).errorStream(eq(testJobId), any(NoSubtitlesFoundException.class));
    }

    @Test
    @DisplayName("예외: 자막 기능이 비활성화된 경우")
    void fetchSubs_subtitlesDisabled() throws TranscriptRetrievalException {
        // Arrange
        String userErrorMessage = "이 영상에는 자막 기능이 비활성화되어 있습니다.";
        TranscriptRetrievalException treException = new TranscriptRetrievalException("Simulated subtitles disabled");
        when(mockApi.listTranscripts(testVideoId)).thenThrow(treException);

        // Act & Assert
        ExecutionException exception = assertThrows(ExecutionException.class, () -> subtitleService.fetchSubs(testJobId, testVideo).get());
        assertTrue(exception.getCause() instanceof NoSubtitlesFoundException);
        assertEquals(userErrorMessage, exception.getCause().getMessage());

        // Verify
        InOrder inOrder = inOrder(mockJobRepository, mockSseNotificationService);
        inOrder.verify(mockJobRepository).updateJob(eq(testJobId), eq(JobStatusDto.JobStatus.SUBTITLE_EXTRACTING), anyString());
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(dto -> dto.status() == JobStatusDto.JobStatus.SUBTITLE_EXTRACTING));
        inOrder.verify(mockJobRepository).updateJob(eq(testJobId), eq(JobStatusDto.JobStatus.FAILED), eq(userErrorMessage));
        inOrder.verify(mockSseNotificationService).notifyJobStatus(argThat(dto -> dto.status() == JobStatusDto.JobStatus.FAILED));
        inOrder.verify(mockSseNotificationService).errorStream(eq(testJobId), any(NoSubtitlesFoundException.class));
    }
}